// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_FILE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_FILE_TYPE: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FILE_TYPE: [FileType; 3] = [
  FileType::Regular,
  FileType::Directory,
  FileType::Symlink,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct FileType(pub i8);
#[allow(non_upper_case_globals)]
impl FileType {
  pub const Regular: Self = Self(0);
  pub const Directory: Self = Self(1);
  pub const Symlink: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Regular,
    Self::Directory,
    Self::Symlink,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Regular => Some("Regular"),
      Self::Directory => Some("Directory"),
      Self::Symlink => Some("Symlink"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for FileType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for FileType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for FileType {
    type Output = FileType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for FileType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for FileType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for FileType {}
pub enum TimespecOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Timespec<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Timespec<'a> {
  type Inner = Timespec<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Timespec<'a> {
  pub const VT_SEC: flatbuffers::VOffsetT = 4;
  pub const VT_NSEC: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Timespec { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TimespecArgs
  ) -> flatbuffers::WIPOffset<Timespec<'bldr>> {
    let mut builder = TimespecBuilder::new(_fbb);
    builder.add_sec(args.sec);
    builder.add_nsec(args.nsec);
    builder.finish()
  }


  #[inline]
  pub fn sec(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Timespec::VT_SEC, Some(0)).unwrap()}
  }
  #[inline]
  pub fn nsec(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Timespec::VT_NSEC, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Timespec<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("sec", Self::VT_SEC, false)?
     .visit_field::<i32>("nsec", Self::VT_NSEC, false)?
     .finish();
    Ok(())
  }
}
pub struct TimespecArgs {
    pub sec: i64,
    pub nsec: i32,
}
impl<'a> Default for TimespecArgs {
  #[inline]
  fn default() -> Self {
    TimespecArgs {
      sec: 0,
      nsec: 0,
    }
  }
}

pub struct TimespecBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TimespecBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_sec(&mut self, sec: i64) {
    self.fbb_.push_slot::<i64>(Timespec::VT_SEC, sec, 0);
  }
  #[inline]
  pub fn add_nsec(&mut self, nsec: i32) {
    self.fbb_.push_slot::<i32>(Timespec::VT_NSEC, nsec, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TimespecBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TimespecBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Timespec<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Timespec<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Timespec");
      ds.field("sec", &self.sec());
      ds.field("nsec", &self.nsec());
      ds.finish()
  }
}
pub enum DirEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DirEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DirEntry<'a> {
  type Inner = DirEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> DirEntry<'a> {
  pub const VT_INO: flatbuffers::VOffsetT = 4;
  pub const VT_PARENT_INO: flatbuffers::VOffsetT = 6;
  pub const VT_SIZE: flatbuffers::VOffsetT = 8;
  pub const VT_BLOCKS: flatbuffers::VOffsetT = 10;
  pub const VT_ATIME: flatbuffers::VOffsetT = 12;
  pub const VT_MTIME: flatbuffers::VOffsetT = 14;
  pub const VT_CTIME: flatbuffers::VOffsetT = 16;
  pub const VT_KIND: flatbuffers::VOffsetT = 18;
  pub const VT_PERM: flatbuffers::VOffsetT = 20;
  pub const VT_NLINK: flatbuffers::VOffsetT = 22;
  pub const VT_UID: flatbuffers::VOffsetT = 24;
  pub const VT_GID: flatbuffers::VOffsetT = 26;
  pub const VT_RDEV: flatbuffers::VOffsetT = 28;
  pub const VT_NAME: flatbuffers::VOffsetT = 30;
  pub const VT_S3_OFFSET: flatbuffers::VOffsetT = 32;
  pub const VT_S3_SIZE: flatbuffers::VOffsetT = 34;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DirEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DirEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<DirEntry<'bldr>> {
    let mut builder = DirEntryBuilder::new(_fbb);
    builder.add_s3_size(args.s3_size);
    builder.add_s3_offset(args.s3_offset);
    builder.add_blocks(args.blocks);
    builder.add_size(args.size);
    builder.add_parent_ino(args.parent_ino);
    builder.add_ino(args.ino);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_rdev(args.rdev);
    builder.add_gid(args.gid);
    builder.add_uid(args.uid);
    builder.add_nlink(args.nlink);
    if let Some(x) = args.ctime { builder.add_ctime(x); }
    if let Some(x) = args.mtime { builder.add_mtime(x); }
    if let Some(x) = args.atime { builder.add_atime(x); }
    builder.add_perm(args.perm);
    builder.add_kind(args.kind);
    builder.finish()
  }


  #[inline]
  pub fn ino(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(DirEntry::VT_INO, Some(0)).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &DirEntry) -> bool {
    self.ino() < o.ino()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: u64) -> ::core::cmp::Ordering {
    let key = self.ino();
    key.cmp(&val)
  }
  #[inline]
  pub fn parent_ino(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(DirEntry::VT_PARENT_INO, Some(0)).unwrap()}
  }
  #[inline]
  pub fn size(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(DirEntry::VT_SIZE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn blocks(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(DirEntry::VT_BLOCKS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn atime(&self) -> Timespec<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Timespec>>(DirEntry::VT_ATIME, None).unwrap()}
  }
  #[inline]
  pub fn mtime(&self) -> Timespec<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Timespec>>(DirEntry::VT_MTIME, None).unwrap()}
  }
  #[inline]
  pub fn ctime(&self) -> Timespec<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Timespec>>(DirEntry::VT_CTIME, None).unwrap()}
  }
  #[inline]
  pub fn kind(&self) -> FileType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<FileType>(DirEntry::VT_KIND, Some(FileType::Regular)).unwrap()}
  }
  #[inline]
  pub fn perm(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(DirEntry::VT_PERM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn nlink(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(DirEntry::VT_NLINK, Some(0)).unwrap()}
  }
  #[inline]
  pub fn uid(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(DirEntry::VT_UID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn gid(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(DirEntry::VT_GID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn rdev(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(DirEntry::VT_RDEV, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DirEntry::VT_NAME, None).unwrap()}
  }
  #[inline]
  pub fn s3_offset(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(DirEntry::VT_S3_OFFSET, Some(0)).unwrap()}
  }
  #[inline]
  pub fn s3_size(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(DirEntry::VT_S3_SIZE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DirEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("ino", Self::VT_INO, false)?
     .visit_field::<u64>("parent_ino", Self::VT_PARENT_INO, false)?
     .visit_field::<u64>("size", Self::VT_SIZE, false)?
     .visit_field::<u64>("blocks", Self::VT_BLOCKS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Timespec>>("atime", Self::VT_ATIME, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<Timespec>>("mtime", Self::VT_MTIME, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<Timespec>>("ctime", Self::VT_CTIME, true)?
     .visit_field::<FileType>("kind", Self::VT_KIND, false)?
     .visit_field::<u16>("perm", Self::VT_PERM, false)?
     .visit_field::<u32>("nlink", Self::VT_NLINK, false)?
     .visit_field::<u32>("uid", Self::VT_UID, false)?
     .visit_field::<u32>("gid", Self::VT_GID, false)?
     .visit_field::<u32>("rdev", Self::VT_RDEV, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
     .visit_field::<u64>("s3_offset", Self::VT_S3_OFFSET, false)?
     .visit_field::<u64>("s3_size", Self::VT_S3_SIZE, false)?
     .finish();
    Ok(())
  }
}
pub struct DirEntryArgs<'a> {
    pub ino: u64,
    pub parent_ino: u64,
    pub size: u64,
    pub blocks: u64,
    pub atime: Option<flatbuffers::WIPOffset<Timespec<'a>>>,
    pub mtime: Option<flatbuffers::WIPOffset<Timespec<'a>>>,
    pub ctime: Option<flatbuffers::WIPOffset<Timespec<'a>>>,
    pub kind: FileType,
    pub perm: u16,
    pub nlink: u32,
    pub uid: u32,
    pub gid: u32,
    pub rdev: u32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub s3_offset: u64,
    pub s3_size: u64,
}
impl<'a> Default for DirEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    DirEntryArgs {
      ino: 0,
      parent_ino: 0,
      size: 0,
      blocks: 0,
      atime: None, // required field
      mtime: None, // required field
      ctime: None, // required field
      kind: FileType::Regular,
      perm: 0,
      nlink: 0,
      uid: 0,
      gid: 0,
      rdev: 0,
      name: None, // required field
      s3_offset: 0,
      s3_size: 0,
    }
  }
}

pub struct DirEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DirEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ino(&mut self, ino: u64) {
    self.fbb_.push_slot::<u64>(DirEntry::VT_INO, ino, 0);
  }
  #[inline]
  pub fn add_parent_ino(&mut self, parent_ino: u64) {
    self.fbb_.push_slot::<u64>(DirEntry::VT_PARENT_INO, parent_ino, 0);
  }
  #[inline]
  pub fn add_size(&mut self, size: u64) {
    self.fbb_.push_slot::<u64>(DirEntry::VT_SIZE, size, 0);
  }
  #[inline]
  pub fn add_blocks(&mut self, blocks: u64) {
    self.fbb_.push_slot::<u64>(DirEntry::VT_BLOCKS, blocks, 0);
  }
  #[inline]
  pub fn add_atime(&mut self, atime: flatbuffers::WIPOffset<Timespec<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Timespec>>(DirEntry::VT_ATIME, atime);
  }
  #[inline]
  pub fn add_mtime(&mut self, mtime: flatbuffers::WIPOffset<Timespec<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Timespec>>(DirEntry::VT_MTIME, mtime);
  }
  #[inline]
  pub fn add_ctime(&mut self, ctime: flatbuffers::WIPOffset<Timespec<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Timespec>>(DirEntry::VT_CTIME, ctime);
  }
  #[inline]
  pub fn add_kind(&mut self, kind: FileType) {
    self.fbb_.push_slot::<FileType>(DirEntry::VT_KIND, kind, FileType::Regular);
  }
  #[inline]
  pub fn add_perm(&mut self, perm: u16) {
    self.fbb_.push_slot::<u16>(DirEntry::VT_PERM, perm, 0);
  }
  #[inline]
  pub fn add_nlink(&mut self, nlink: u32) {
    self.fbb_.push_slot::<u32>(DirEntry::VT_NLINK, nlink, 0);
  }
  #[inline]
  pub fn add_uid(&mut self, uid: u32) {
    self.fbb_.push_slot::<u32>(DirEntry::VT_UID, uid, 0);
  }
  #[inline]
  pub fn add_gid(&mut self, gid: u32) {
    self.fbb_.push_slot::<u32>(DirEntry::VT_GID, gid, 0);
  }
  #[inline]
  pub fn add_rdev(&mut self, rdev: u32) {
    self.fbb_.push_slot::<u32>(DirEntry::VT_RDEV, rdev, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DirEntry::VT_NAME, name);
  }
  #[inline]
  pub fn add_s3_offset(&mut self, s3_offset: u64) {
    self.fbb_.push_slot::<u64>(DirEntry::VT_S3_OFFSET, s3_offset, 0);
  }
  #[inline]
  pub fn add_s3_size(&mut self, s3_size: u64) {
    self.fbb_.push_slot::<u64>(DirEntry::VT_S3_SIZE, s3_size, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DirEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DirEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DirEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, DirEntry::VT_ATIME,"atime");
    self.fbb_.required(o, DirEntry::VT_MTIME,"mtime");
    self.fbb_.required(o, DirEntry::VT_CTIME,"ctime");
    self.fbb_.required(o, DirEntry::VT_NAME,"name");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DirEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DirEntry");
      ds.field("ino", &self.ino());
      ds.field("parent_ino", &self.parent_ino());
      ds.field("size", &self.size());
      ds.field("blocks", &self.blocks());
      ds.field("atime", &self.atime());
      ds.field("mtime", &self.mtime());
      ds.field("ctime", &self.ctime());
      ds.field("kind", &self.kind());
      ds.field("perm", &self.perm());
      ds.field("nlink", &self.nlink());
      ds.field("uid", &self.uid());
      ds.field("gid", &self.gid());
      ds.field("rdev", &self.rdev());
      ds.field("name", &self.name());
      ds.field("s3_offset", &self.s3_offset());
      ds.field("s3_size", &self.s3_size());
      ds.finish()
  }
}
pub enum DirEntryPageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DirEntryPage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DirEntryPage<'a> {
  type Inner = DirEntryPage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> DirEntryPage<'a> {
  pub const VT_DIRENTS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DirEntryPage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DirEntryPageArgs<'args>
  ) -> flatbuffers::WIPOffset<DirEntryPage<'bldr>> {
    let mut builder = DirEntryPageBuilder::new(_fbb);
    if let Some(x) = args.dirents { builder.add_dirents(x); }
    builder.finish()
  }


  #[inline]
  pub fn dirents(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DirEntry<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DirEntry>>>>(DirEntryPage::VT_DIRENTS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for DirEntryPage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DirEntry>>>>("dirents", Self::VT_DIRENTS, true)?
     .finish();
    Ok(())
  }
}
pub struct DirEntryPageArgs<'a> {
    pub dirents: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DirEntry<'a>>>>>,
}
impl<'a> Default for DirEntryPageArgs<'a> {
  #[inline]
  fn default() -> Self {
    DirEntryPageArgs {
      dirents: None, // required field
    }
  }
}

pub struct DirEntryPageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DirEntryPageBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_dirents(&mut self, dirents: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DirEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DirEntryPage::VT_DIRENTS, dirents);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DirEntryPageBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DirEntryPageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DirEntryPage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, DirEntryPage::VT_DIRENTS,"dirents");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DirEntryPage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DirEntryPage");
      ds.field("dirents", &self.dirents());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `DirEntryPage`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_dir_entry_page_unchecked`.
pub fn root_as_dir_entry_page(buf: &[u8]) -> Result<DirEntryPage, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<DirEntryPage>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `DirEntryPage` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_dir_entry_page_unchecked`.
pub fn size_prefixed_root_as_dir_entry_page(buf: &[u8]) -> Result<DirEntryPage, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<DirEntryPage>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `DirEntryPage` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_dir_entry_page_unchecked`.
pub fn root_as_dir_entry_page_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<DirEntryPage<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<DirEntryPage<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `DirEntryPage` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_dir_entry_page_unchecked`.
pub fn size_prefixed_root_as_dir_entry_page_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<DirEntryPage<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<DirEntryPage<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a DirEntryPage and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `DirEntryPage`.
pub unsafe fn root_as_dir_entry_page_unchecked(buf: &[u8]) -> DirEntryPage {
  unsafe { flatbuffers::root_unchecked::<DirEntryPage>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed DirEntryPage and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `DirEntryPage`.
pub unsafe fn size_prefixed_root_as_dir_entry_page_unchecked(buf: &[u8]) -> DirEntryPage {
  unsafe { flatbuffers::size_prefixed_root_unchecked::<DirEntryPage>(buf) }
}
#[inline]
pub fn finish_dir_entry_page_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<DirEntryPage<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_dir_entry_page_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<DirEntryPage<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
